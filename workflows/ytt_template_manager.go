package workflows

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/jbrunton/gflows/adapters"
	"github.com/jbrunton/gflows/config"
	"github.com/spf13/afero"
)

type YttTemplateManager struct {
	fs      *afero.Afero
	logger  *adapters.Logger
	context *config.GFlowsContext
}

func NewYttTemplateManager(fs *afero.Afero, logger *adapters.Logger, context *config.GFlowsContext) *YttTemplateManager {
	return &YttTemplateManager{
		fs:      fs,
		logger:  logger,
		context: context,
	}
}

func (manager *YttTemplateManager) GetWorkflowSources() []string {
	files := []string{}
	err := manager.fs.Walk(manager.context.WorkflowsDir, func(path string, f os.FileInfo, err error) error {
		if filepath.Dir(path) == manager.context.WorkflowsDir {
			// ignore files in the top level workflows dir, as we need them to be in a nested directory to infer the template name
			return nil
		}
		ext := filepath.Ext(path)
		if ext == ".yml" || ext == ".yaml" || ext == ".txt" {
			files = append(files, path)
		}
		return nil
	})

	if err != nil {
		panic(err)
	}

	return files
}

func (manager *YttTemplateManager) GetWorkflowTemplates() []string {
	// sources := manager.GetWorkflowSources()
	// var templates []string
	// for _, source := range sources {
	// 	relPath, _ := filepath.Rel(manager.context.WorkflowsDir, source)
	// 	topDir := filepath.SplitList(relPath)[0]
	// 	templates = append(templates, topDir)
	// }
	// return templates
	templates := []string{}
	paths, err := afero.Glob(manager.fs, filepath.Join(manager.context.WorkflowsDir, "/*"))
	if err != nil {
		panic(err)
	}
	for _, path := range paths {
		isDir, err := manager.fs.IsDir(path)
		if err != nil {
			panic(err)
		}
		if isDir {
			templates = append(templates, path)
		}
	}
	return templates
}

// GetWorkflowDefinitions - get workflow definitions for the given context
func (manager *YttTemplateManager) GetWorkflowDefinitions() ([]*WorkflowDefinition, error) {
	templates := manager.GetWorkflowTemplates()
	definitions := []*WorkflowDefinition{}
	for _, templatePath := range templates {
		vm := createVM(manager.context)
		workflowName := manager.getWorkflowName(manager.context.WorkflowsDir, templatePath)
		input, err := manager.fs.ReadFile(templatePath)
		if err != nil {
			return []*WorkflowDefinition{}, err
		}

		destinationPath := filepath.Join(manager.context.GitHubDir, "workflows/", workflowName+".yml")
		definition := &WorkflowDefinition{
			Name:        workflowName,
			Source:      templatePath,
			Destination: destinationPath,
			Status:      ValidationResult{Valid: true},
		}

		workflow, err := vm.EvaluateSnippet(templatePath, string(input))
		if err != nil {
			definition.Status.Valid = false
			definition.Status.Errors = []string{strings.Trim(err.Error(), " \n\r")}
		} else {
			meta := strings.Join([]string{
				"# File generated by gflows, do not modify",
				fmt.Sprintf("# Source: %s", templatePath),
			}, "\n")
			definition.Content = meta + "\n" + workflow
		}
		definitions = append(definitions, definition)
	}

	return definitions, nil
}

func (manager *YttTemplateManager) getWorkflowName(workflowsDir string, filename string) string {
	_, templateFileName := filepath.Split(filename)
	return strings.TrimSuffix(templateFileName, filepath.Ext(templateFileName))
}
